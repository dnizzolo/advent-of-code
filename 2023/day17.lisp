(defpackage :aoc2023.17
  (:documentation "Clumsy Crucible.")
  (:local-nicknames (:pq :min-priority-queue))
  (:use :cl :aoc.utils))

(in-package :aoc2023.17)

(defun read-map (&optional (relative-pathname #p"2023/inputs/day17.txt"))
  (let ((filename (asdf:system-relative-pathname :advent-of-code relative-pathname)))
    (let* ((strings (uiop:read-file-lines filename))
           (lines (mapcar (lambda (s) (map 'list #'digit-char-p s)) strings)))
      (make-array (list (length lines) (length (first lines)))
                  :initial-contents lines :element-type 'unsigned-byte))))

(defun make-state (i j di dj consec) (vector i j di dj consec))

(defun minimize-heat-loss (map
                           &aux
                             (initial-state (make-state 0 0 0 0 0))
                             (n (array-dimension map 0)) (m (array-dimension map 1))
                             (final-i (1- n)) (final-j (1- m))
                             (heap (pq:make-min-priority-queue))
                             (distance (make-hash-table :test #'equalp)))
  (pq:insert heap initial-state 0)
  (setf (gethash initial-state distance) 0)
  (loop while (pq:peek-min heap)
        for curr = (pq:extract-min heap)
        for dist = (gethash curr distance)
        for i = (svref curr 0) for j = (svref curr 1)
        for di = (svref curr 2) for dj = (svref curr 3)
        for consec = (svref curr 4)
        do (cond
             ((and (= i final-i) (= j final-j))
              (return dist))
             (t
              (loop for (ndi ndj) in '((0 1) (0 -1) (1 0) (-1 0))
                    for ni = (+ i ndi) for nj = (+ j ndj)
                    when (and (array-in-bounds-p map ni nj)
                              (or (/= (abs ndi) di) (/= (abs ndj) dj)))
                      do (let ((next (make-state ni nj ndi ndj 1))
                               (cost (+ dist (aref map ni nj))))
                           (unless (gethash next distance)
                             (pq:insert heap next cost)
                             (setf (gethash next distance) cost))))
              (unless (or (= 3 consec) (zerop consec))
                (let ((ni (+ i di)) (nj (+ j dj)))
                  (when (array-in-bounds-p map ni nj)
                    (let ((next (make-state ni nj di dj (1+ consec)))
                          (cost (+ dist (aref map ni nj))))
                      (unless (gethash next distance)
                        (pq:insert heap next cost)
                        (setf (gethash next distance) cost))))))))))

(defun minimize-heat-loss-ultra (map
                                 &aux
                                   (initial-state (make-state 0 0 0 0 0))
                                   (n (array-dimension map 0)) (m (array-dimension map 1))
                                   (final-i (1- n)) (final-j (1- m))
                                   (heap (pq:make-min-priority-queue))
                                   (distance (make-hash-table :test #'equalp)))
  (pq:insert heap initial-state 0)
  (setf (gethash initial-state distance) 0)
  (loop while (pq:peek-min heap)
        for curr = (pq:extract-min heap)
        for dist = (gethash curr distance)
        for i = (svref curr 0) for j = (svref curr 1)
        for di = (svref curr 2) for dj = (svref curr 3)
        for consec = (svref curr 4)
        do (cond
             ((and (= i final-i) (= j final-j))
              (return dist))
             (t
              (when (and (or (zerop consec) (>= consec 4)) (zerop dj))
                (loop for nj in (list (1- j) (1+ j))
                      when (array-in-bounds-p map i nj)
                        do (let ((next (make-state i nj 0 (- nj j) 1))
                                 (cost (+ dist (aref map i nj))))
                             (unless (gethash next distance)
                               (pq:insert heap next cost)
                               (setf (gethash next distance) cost)))))
              (when (and (or (zerop consec) (>= consec 4)) (zerop di))
                (loop for ni in (list (1- i) (1+ i))
                      when (array-in-bounds-p map ni j)
                        do (let ((next (make-state ni j (- ni i) 0 1))
                                 (cost (+ dist (aref map ni j))))
                             (unless (gethash next distance)
                               (pq:insert heap next cost)
                               (setf (gethash next distance) cost)))))
              (unless (or (zerop consec) (= 10 consec))
                (let ((ni (+ i di)) (nj (+ j dj)))
                  (when (array-in-bounds-p map ni nj)
                    (let ((next (make-state ni nj di dj (1+ consec)))
                          (cost (+ dist (aref map ni nj))))
                      (unless (gethash next distance)
                        (pq:insert heap next cost)
                        (setf (gethash next distance) cost))))))))))

(defun day17 (&aux (map (read-map)))
  (values (minimize-heat-loss map) (minimize-heat-loss-ultra map)))

(define-test (= 1039) (= 1201))
